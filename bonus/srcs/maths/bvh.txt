

int	queue_helper(t_queue *q, int depth)
{
	t_hitbox	*l;
	t_hitbox	*r;
	t_hitbox	*dad;

	while (queue_size(q) > 1)
	{
		l = queue_pop(q);
		r = NULL;
		if (!queue_is_empty(q))
			r = queue_pop(q);
		dad = create_bvh_node(l, r);
		if (!dad)
			return (1);
		dad->box = box_around_two_box(&l->box, &r->box);
		l->depth = depth;
		r->depth = depth;
		queue_push(q, dad);
		dad->depth = depth;
	}
	return (0);
}

t_hitbox	*queue_helper_2(t_all *all, t_queue *q, int i)
{
	t_hitbox	*dad;

	dad = NULL;
	if (all->shapes[i].type == SPHERE)
		dad = box_around_sphere(all->shapes[i].shape);
	else if (all->shapes[i].type == BOX)
		dad = box_around_box(all->shapes[i].shape);
	else if (all->shapes[i].type == CYLINDER)
		dad = box_around_cylinder(all->shapes[i].shape);
	else if (all->shapes[i].type == OBJECT)
		dad = create_bvh_triangles(all->shapes[i].shape);
	if (!dad)
	{
		while (i && --i)
			free(q->nodes[i]);
		return (queue_free(q));
	}
	return (dad);
}

t_hitbox	*create_bvh_iter(t_all *all, int end, int depth)
{
	t_queue		q;
	t_hitbox	*dad;
	int			i;

	if (queue_init(&q, end))
		return (NULL);
	dad = NULL;
	i = -1;
	while (++i < end)
	{
		dad = queue_helper_2(all, &q, i);
		queue_push(&q, dad);
	}
	if(queue_helper(&q, depth))
		return (NULL);
	dad = queue_pop(&q);
	queue_free(&q);
	if (dad->node_type == INTERNAL)
	{
		dad->node_type = ROOT;
		dad->type = OBJECT;
	}
	return (dad);
}







#include "miniRT.h"
#include "tri_lib.h"

// int	shadow_intersect_sphere(t_ray *ray, t_sphere *sphere,
// 			t_vec light_dir, double light_lenght)
// {
// 	double			disciminant;
// 	const t_vec		CO = sub_vectors_no_v(&ray->hit, &sphere->coord);
// 	const double	b = 2 * dot_product((t_vec *)&CO, &light_dir);
// 	const double	c = dot_product((t_vec *)&CO, (t_vec *)&CO)
// - sphere->radius_squared;
// 	double			t;

// 	disciminant = b * b - 4.0 * c;
// le a dans "b * b - 4 * a * c" supprimé car
// a = dot d'un vecteur unitaire avec lui même ce qui donne toujours 1
// 	if (disciminant < 0)
// 		return (0);
// 	disciminant = sqrt(disciminant);
// 	t = (-b - disciminant) / 2.0;
// 	if ((t >= 1e-6 && t < light_lenght))
// 		return (1);
// 	//t = (-b + disciminant) / 2.0;
// 	//if ((t >= 1e-6 && t < light_lenght))
// 	//	return (1);
// 	return (0);
// }

int	check_t(t_quad q, t_ray *ray, t_cylinder *cylinder, t_light_vec l)
{
	t_vec		p;
	double		mag;
	const t_vec	*cyl_co = &cylinder->coord;

	q.t = (q.b - q.discriminant) / q.a;
	if (q.t >= 1e-6 && q.t < l.light_lenght)
	{
		add_vectors(&ray->hit,
			scalar_multiplication(&l.light_dir, q.t, &p), &p);
		mag = dot_product(sub_vectors(&p, (t_vec *)cyl_co, &p), &cylinder->vec);
		if (mag >= 0
			&& mag <= cylinder->height && !isnan(mag) && !isinf(mag))
			return (1);
	}
	q.t = (q.b + q.discriminant) / q.a;
	if (q.t >= 1e-6 && q.t < l.light_lenght)
	{
		add_vectors(&ray->hit,
			scalar_multiplication(&l.light_dir, q.t, &p), &p);
		mag = dot_product(sub_vectors(&p, (t_vec *)cyl_co, &p), &cylinder->vec);
		if (mag >= 0
			&& mag <= cylinder->height && !isnan(mag) && !isinf(mag))
			return (1);
	}
	return (0);
}

int	shadow_traverse_bvh_core(t_ray *ray, t_hitbox *curr, t_light_vec l)
{
	if (curr->type == SPHERE
		&& shadow_intersect_sphere(ray, curr->shape,
			l.light_dir, l.light_lenght))
		return (1);
	else if (curr->type == BOX
		&& shadow_intersect_bvh(ray, curr->shape, l.light_dir))
		return (1);
	else if (curr->type == CYLINDER
		&& shadow_intersect_cylinder(ray, curr->shape,
			l.light_dir, l.light_lenght))
		return (1);
	else if (curr->type == TRIANGLE
		&& shadow_intersect_quad(ray, curr->shape,
			l.light_dir, l.light_lenght))
		return (1);
	return (0);
}

void	push_correct_hitbox(t_queue *q, t_hitbox *curr)
{
	if (curr->left)
		queue_push(q, curr->left);
	if (curr->right)
		queue_push(q, curr->right);
}

int	shadow_traverse_bvh_iter(t_ray *ray, t_hitbox *bvh,
	t_vec light_dir,
	double light_length)
{
	t_queue		q;
	t_hitbox	*curr;

	if (queue_init(&q, __get_all()->nb_shapes))
		return (1);
	queue_push(&q, bvh);
	while (!queue_is_empty(&q))
	{
		curr = queue_pop(&q);
		if (!curr || !shadow_intersect_bvh(ray, &curr->box, light_dir))
			continue ;
		if (curr->node_type == LEAF)
		{
			if (shadow_traverse_bvh_core(ray, curr,
					(t_light_vec){light_dir, light_length}))
				return (queue_free(&q), 1);
		}
		else
			push_correct_hitbox(&q, curr);
	}
	queue_free(&q);
	return (0);
}

void	specular(t_ray *ray, t_vec light_dir, t_light *light, double light_scale)
{
	t_vec	v;
	t_vec	h;
	double	ndoth;
	double	intensity;

	v = scalar_multiplication_no_v(&ray->dir, -1);
	add_vectors(&light_dir, &v, &h);
	norm_vectors(&h, vec_magnitude(&h), &h);
	ndoth = dot_product(&ray->shape.normal, &h);
	if (ndoth <= 0)
		return ;
	intensity = ray->shape.material.ks * pow(ndoth, ray->shape.material.shininess) * light_scale;
	ray->color_specular.r += light->rgb_norm.r * intensity;
	ray->color_specular.g += light->rgb_norm.g * intensity;
	ray->color_specular.b += light->rgb_norm.b * intensity;
}

void	get_rgb_norm_light_intensity(t_ray *ray, t_all *all, t_light *light)
{
	t_vec		light_dir;
	double		light_length;
	double		light_length_square;
	double		intensity;
	double		light_scale;

	sub_vectors(&light->coord, &ray->hit, &light_dir);
	light_length_square = light_dir.x * light_dir.x
		+ light_dir.y * light_dir.y + light_dir.z * light_dir.z;
	light_length = sqrt(light_length_square);
	norm_vectors(&light_dir, light_length, &light_dir);
	intensity = dot_product(&ray->shape.normal, &light_dir);
	if (intensity >= 0)
	{	
		if (all->shadow_on
			&&
				((plane_on_the_path(ray, all->planes,
					light_dir, light_length))
				|| shadow_traverse_bvh_iter(ray, all->bvh, light_dir, light_length)))
				return ;
		light_scale = (light->ratio * (all->distance_light
					/ (light_length_square + all->distance_light)));
		specular(ray, light_dir, light, light_scale);
		intensity *= light_scale;
		ray->color_diffuse.r += light->rgb_norm.r * intensity;
		ray->color_diffuse.g += light->rgb_norm.g * intensity;
		ray->color_diffuse.b += light->rgb_norm.b * intensity;
	}
}

void	diffuse_light(t_ray *ray, t_all *all, t_light *light)
{
	t_rgb_f	ambiant_light;

	while (light)
	{
		get_rgb_norm_light_intensity(ray, all, light);
		light = light->next;
	}
	ambiant_light = all->ambient_light.rgb_norm;
	ray->color_diffuse.r += ambiant_light.r;
	ray->color_diffuse.g += ambiant_light.g;
	ray->color_diffuse.b += ambiant_light.b;
}










#include "miniRT.h"
#include "tri_lib.h"

void	closest_plane(t_ray *ray, t_plane *plane)
{
	while (plane)
	{
		intersect_plane(ray, plane);
		plane = plane->next;
	}
}

#ifdef SSAA

void	init_ray(t_ray *ray, t_all *all)
{
	ray->end = 0;
	if (all->render_hitbox && !(ray->x % 2) && !(ray->y % 2))
		_replace_pixel_on_render(all->render_hb, 0, ray->y >> 1, ray->x >> 1);
	ray->color_shape = (t_rgb_f){0, 0, 0};
	ray->color_diffuse = (t_rgb_f){0, 0, 0};
	ray->color_specular = (t_rgb_f){0, 0, 0};
	ray->color_ray = (t_rgb_f){0, 0, 0};
	ray->shape.type = CAMERA;
	ray->shape.shape = NULL;
	ray->reflection = (t_rgb_f){1, 1, 1};
	ray->shape.t1 = INFINITY;
	ray->shape.t2 = INFINITY;
}

#else

void	init_ray(t_ray *ray, t_all *all)
{
	ray->end = 0;
	if (all->render_hitbox)
		_replace_s_px_on_render(all->render_hb, 0,
			(t_point2d){ray->y, ray->x}, all->canvas.pixel_values);
	ray->color_shape = (t_rgb_f){0, 0, 0};
	ray->color_diffuse = (t_rgb_f){0, 0, 0};
	ray->color_specular = (t_rgb_f){0, 0, 0};
	ray->color_ray = (t_rgb_f){0, 0, 0};
	ray->shape.type = CAMERA;
	ray->shape.shape = NULL;
	ray->reflection = (t_rgb_f){1, 1, 1};
	ray->shape.t1 = INFINITY;
	ray->shape.t2 = INFINITY;
}

#endif

void	init_reflect_ray(t_ray *ray, t_all *all)
{
	t_vec	vec;

	(void)all;
	ray->color_shape = (t_rgb_f){0, 0, 0};
	ray->color_diffuse = (t_rgb_f){0, 0, 0};
	ray->color_specular = (t_rgb_f){0, 0, 0};
	add_vectors(&ray->hit, scalar_multiplication(&ray->shape.normal,
			1e-6, &vec), &ray->start);
	vec = scalar_multiplication_no_v(&ray->shape.normal, 2.0
			* dot_product(&ray->shape.normal, &ray->dir));
	ray->dir = sub_vectors_no_v(&ray->dir, &vec);
	norm_vectors(&ray->dir, vec_magnitude(&ray->dir), &ray->dir);
	ray->shape.type = CAMERA;
	ray->shape.shape = NULL;
	ray->shape.t1 = INFINITY;
	ray->shape.t2 = INFINITY;
}

static void	if_leaf_internal(t_all *all, t_ray *ray, t_hitbox *curr, t_queue *q)
{
	if (curr->node_type == LEAF)
	{
		if (!all->render_on)
			return ;
		if (curr->type == SPHERE)
			intersect_ray_sphere(ray, (t_sphere *)curr->shape);
		else if (curr->type == CYLINDER)
			intersect_cylinder(ray, (t_cylinder *)curr->shape);
		else if (curr->type == BOX)
			intersect_box(ray, (t_box *)curr->shape);
		else if (curr->type == TRIANGLE)
			intersect_quad(ray, (t_face *)curr->shape);
	}
	else
	{
		if (curr->left)
			queue_push(q, curr->left);
		if (curr->right)
			queue_push(q, curr->right);
	}
}

#ifdef SSAA

void	traverse_bvh_iter(t_ray *ray, t_hitbox *bvh, t_render *render, int hb)
{
	t_queue			q;
	t_hitbox		*curr;
	const t_all		*all = __get_all();
	const t_tri_lib	*lib = tri_lib();

	if (queue_init(&q, all->nb_items))
		return ;
	queue_push(&q, bvh);
	while (!queue_is_empty(&q))
	{
		curr = queue_pop(&q);
		if (!curr || !intersect_hitbox(ray, &curr->box))
			continue ;
		if (hb && !(ray->x % 2) && !(ray->y % 2))
			lib->put_pixel_to_render(render, (t_argb){.a = 0.25,
				.r = 255, .g = 255, .b = 255}, ray->y >> 1, ray->x >> 1);
		if_leaf_internal((t_all *)all, ray, curr, &q);
	}
	queue_free(&q);
}

#else

void	traverse_bvh_iter(t_ray *ray, t_hitbox *bvh, t_render *render, int hb)
{
	t_queue			q;
	t_hitbox		*curr;
	const t_all		*all = __get_all();
	const t_tri_lib	*lib = tri_lib();

	if (queue_init(&q, all->nb_items))
		return ;
	queue_push(&q, bvh);
	while (!queue_is_empty(&q))
	{
		curr = queue_pop(&q);
		if (!curr || !intersect_hitbox(ray, &curr->box))
			continue ;
		if (hb)
			lib->put_pixel_to_render(render, (t_argb){.a = 0.25, .r = 255,
				.g = 255, .b = 255}, ray->y, ray->x);
		if_leaf_internal((t_all *)all, ray, curr, &q);
	}
	queue_free(&q);
}

#endif

void	get_local_color(t_ray *ray, t_all *all)
{
	t_rgb_f	reflection;

	if (isinf(ray->shape.t1) || ray->end)
	{
		ray->end = 1;
		return ;
	}
	ray->hit = scalar_multiplication_no_v(&ray->dir, ray->shape.t1);
	add_vectors(&ray->hit, &ray->start, &ray->hit);
	set_shapes(ray);
	if (dot_product(&ray->shape.normal, &ray->dir) > 0)
		ray->shape.normal = (t_vec){-ray->shape.normal.x,
			-ray->shape.normal.y, -ray->shape.normal.z};
	diffuse_light(ray, all, all->lights);
	reflection = ray->shape.material.reflection;
	ray->color_ray.r += (ray->color_shape.r * ray->color_diffuse.r
			+ ray->color_specular.r) * (1.0 - reflection.r) * ray->reflection.r;
	ray->color_ray.g += (ray->color_shape.g * ray->color_diffuse.g
			+ ray->color_specular.g) * (1.0 - reflection.g) * ray->reflection.g;
	ray->color_ray.b += (ray->color_shape.b * ray->color_diffuse.b
			+ ray->color_specular.b) * (1.0 - reflection.b) * ray->reflection.b;
	ray->reflection.r *= reflection.r;
	ray->reflection.g *= reflection.g;
	ray->reflection.b *= reflection.b;
	ray->to_draw = 1;
	if (ray->reflection.r < 1 && ray->reflection.g < 1 && ray->reflection.b < 1)
		ray->end = 1;
}

void	init_color_ray(t_ray *ray)
{
	if (!ray->end)
		ray->color_ray = (t_rgb_f){0, 0, 0};
}

void	get_closest_color(t_ray *ray, t_all *all)
{
	init_ray(ray, all);
	closest_plane(ray, all->planes);
	traverse_bvh_iter(ray, all->bvh, all->render_hb, all->render_hitbox);
	if (isinf(ray->shape.t1))
	{
		ray->end = 1;
		ray->color_ray = ray->color;
	}
	else if (ray->shape.type == (t_obj_type)CYLINDER)
		ray->color_ray = ((t_cylinder *)(ray->shape.shape))->color;
	else if (ray->shape.type == (t_obj_type)SPHERE)
		ray->color_ray = ((t_sphere *)(ray->shape.shape))->color;
	else if (ray->shape.type == (t_obj_type)BOX)
		ray->color_ray = ((t_box *)(ray->shape.shape))->color;
	else if (ray->shape.type == (t_obj_type)PLANE)
		ray->color_ray = ((t_plane *)(ray->shape.shape))->color;
	ray->to_draw = 1;
}

void	traceray_reflection(t_ray *ray, t_all *all)
{
	if (ray->end)
		return ;
	init_reflect_ray(ray, all);
	closest_plane(ray, all->planes);
	traverse_bvh_iter(ray, all->bvh, all->render_hb, 0);
	get_local_color(ray, all);
}

#ifdef SSAA

t_thread_mode	iter_rays_line_stop(t_all *all,
	t_threads *thread,
	void (*f)(t_ray *, t_all *)
)
{
	int				i;
	int				j;

	i = thread->start;
	while (i < thread->end)
	{
		j = 0;
		while (j < all->win_width)
		{
			all->canvas.rays[i][j].y = j;
			all->canvas.rays[i][j].x = i;
			f(&all->canvas.rays[i][j], all);
			++j;
		}
		if (get_thread_mode_pause(all, thread) == (t_thread_mode)STOP)
			return ((t_thread_mode)STOP);
		else if (thread->mode == (t_thread_mode)RESET)
			return ((t_thread_mode)RESET);
		++i;
	}
	return (((t_thread_mode)CONTINUE));
}

void	iter_rays(t_all *all, t_threads *thread, void (*f)(t_ray *))
{
	int				i;
	int				j;

	i = thread->start;
	while (i < thread->end)
	{
		j = 0;
		while (j < all->win_width)
		{
			f(&all->canvas.rays[i][j]);
			++j;
		}
		++i;
	}
}

#else

void	if_iter_rays_line(t_all *all,
	int index[2],
	int real[2],
	void (*f)(t_ray *, t_all *)
)
{
	if (index[1] >= all->win_width)
		index[1] = all->win_width - 1;
	all->canvas.rays[index[0]][index[1]].y = index[1];
	all->canvas.rays[index[0]][index[1]].x = index[0];
	f(&all->canvas.rays[index[0]][index[1]], all);
	real[1] += all->canvas.pixel_values;
}

t_thread_mode	iter_rays_line_stop(t_all *all,
	t_threads *thread,
	void (*f)(t_ray *, t_all *)
)
{
	int				index[2];
	int				real[2];
	const int		mi_pix = all->canvas.pixel_values >> 1;

	real[0] = thread->start;
	index[0] = mi_pix + real[0];
	while (real[0] < thread->end)
	{
		real[1] = 0;
		index[1] = mi_pix;
		if (index[0] >= thread->end)
			index[0] = thread->end - 1;
		while (real[1] < all->win_width)
		{
			if_iter_rays_line(all, index, real, f);
			index[1] = real[1] + mi_pix;
		}
		if (get_thread_mode_pause(all, thread) == (t_thread_mode)STOP
			|| thread->mode == (t_thread_mode)RESET)
			return (thread->mode);
		real[0] += all->canvas.pixel_values;
		index[0] = real[0] + mi_pix;
	}
	return (((t_thread_mode)CONTINUE));
}

void	iter_rays(t_all *all, t_threads *thread, void (*f)(t_ray *))
{
	int				index[2];
	int				real[2];
	const int		mi_pix = all->canvas.pixel_values >> 1;

	real[0] = thread->start;
	index[0] = mi_pix + real[0];
	while (real[0] < thread->end)
	{
		real[1] = 0;
		index[1] = mi_pix;
		if (index[0] >= thread->end)
			index[0] = thread->end - 1;
		while (real[1] < all->win_width)
		{
			if (index[1] >= all->win_width)
				index[1] = all->win_width - 1;
			f(&all->canvas.rays[index[0]][index[1]]);
			real[1] += all->canvas.pixel_values;
			index[1] = real[1] + mi_pix;
		}
		real[0] += all->canvas.pixel_values;
		index[0] = real[0] + mi_pix;
	}
}

#endif
